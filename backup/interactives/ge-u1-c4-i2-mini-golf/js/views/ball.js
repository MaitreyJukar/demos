(function () {
    'use strict';

    var miniGolfModel = MathInteractives.Interactivities.MiniGolf.Models.MiniGolfData;
    /**
    * Ball holds the rasters and related manipulation methods .
    * @class Ball
    * @namespace MathInteractives.Interactivities.MiniGolf.Views
    * @extends MathInteractives.Common.Player.Views.Base
    * @constructor
    */
    MathInteractives.Interactivities.MiniGolf.Views.Ball = MathInteractives.Common.Player.Views.Base.extend({

        /**
        * Paperscope of the canvas. Paperscope will be supplied by initializer.
        * @property paperScope
        * @default null
        * @type Object
        */
        paperScope: null,

        /**
        * Holds base64 URL for the ball image.
        * @property ball64URL
        * @default null
        * @type String
        */
        ball64URL: null,

        /**
        * Holds base64 URL for the sticky slider image.
        * @property stickySliderbase64URL
        * @default null
        * @type String
        */
        stickySliderbase64URL: null,

        /**
        * Holds sticky slider raster paper object.Image URL is taken from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderbase64URL:property"}}{{/crossLink}}.
        * @property stickySliderRaster
        * @default null
        * @type Object
        */
        stickySliderRaster: null,

        /**
        * Holds ball raster object. ball is generated by {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_clipBallBackground:method"}}{{/crossLink}}.
        * @property ball
        * @default null
        * @type Object
        */
        ball: null,

        /**
        * Holds ball base 64 image URL.{{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballInnerRaster:property"}}{{/crossLink}} is using this url.
        * @property ballBase64URL
        * @default null
        * @type String
        */
        ballBase64URL: null,

        /**
        * Holds balls inner shadow raster.Image URL is taken from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballBase64URL:property"}}{{/crossLink}}.
        * @property ballInnerRaster
        * @default null
        * @type Object
        */
        ballInnerRaster: null,

        /**
        * Holds ball outer shadow base64 image URL.
        * @property ballShadowBase64URL
        * @default null
        * @type String
        */
        ballShadowBase64URL: null,

        /**
        * Holds balls shadow raster.Image URL is taken from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballShadowBase64URL:property"}}{{/crossLink}}.
        * @property ballShadowRaster
        * @default null
        * @type Object
        */
        ballShadowRaster: null,

        /**
        * Holds ball inner texture image base 64 URL.
        * @property ballTextureBase64URL
        * @default null
        * @type String
        */
        ballTextureBase64URL: null,

        /**
        * Holds ball inner texture raster paper Object. Image URL is taken from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballTextureBase64URL:property"}}{{/crossLink}}.
        * @property ballTextureRaster
        * @default null
        * @type Object
        */
        ballTextureRaster: null,

        /**
        * Holds ball group paper Object.This group contains {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}}, {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}}.
        * @property ballGroup
        * @default null
        * @type Object
        */
        ballGroup: null,

        /**
        * Holds current view's model. {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}}, {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball"}}{{/crossLink}}.
        * @property ballModel
        * @default null
        * @type Object
        */
        ballModel: null,

        /**
        * Holds paper object for the line from current {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}} to next view's {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}}.
        * @property connectorLine
        * @default null
        * @type Object
        */
        connectorLine: null,

        /**
        * Holds paper object for the line for perpendicular of the reflection surface.
        * It's endpoints are {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/snapPoint:attribute"}}{{/crossLink}} and {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/mirrorPoint:attribute"}}{{/crossLink}}.
        *
        * @property mirrorLine
        * @default null
        * @type Object
        */
        mirrorLine: null,

        /**
        * Holds paper object view of the arc with the previous {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderPrevBallAngle:method"}}{{/crossLink}}.
        *
        * @property arcWithPrevBall
        * @default null
        * @type Object
        */
        arcWithPrevBall: null,

        /**
        * Holds paper object view of the arc with the next {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderNextBallAngle:method"}}{{/crossLink}}.
        *
        * @property arcWithNextBall
        * @default null
        * @type Object
        */
        arcWithNextBall: null,

        /**
        * Holds paper object view of the angle text with the prev {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}}.
        * Value is retrieved from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/prevBallAngle:attribute"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderPrevBallAngle:method"}}{{/crossLink}}.
        *
        * @property prevAngleText
        * @default null
        * @type Object
        */
        prevAngleText: null,

        /**
        * Holds paper object view of the angle text with the prev {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}}.
        * Value is retrieved from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/nextBallAngle:attribute"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderNextBallAngle:method"}}{{/crossLink}}.
        *
        * @property nextAngleText
        * @default null
        * @type Object
        */
        nextAngleText: null,

        ghostBall: null,

        purpleBorder: null,

        rectangleCover: null,

        isDisabled: null,

        ballFocusRect: null,
        stickySliderFocusRect: null,

        /**
        * Holds the outermost path on which all events on the ball are fired
        * @property dummyPath
        * @default null
        * @type Object
        */
        dummyPath: null,

        /**
        * Initializes function of ball view.
        * @method initialize
        * @constructor
        */
        initialize: function () {
            this.initializeDefaultProperties();
            this._readProperties();
        },
        initializeDefaultProperties:function(){
            this._superwrapper('initializeDefaultProperties',arguments);
            this.isMobile=MathInteractives.Common.Utilities.Models.BrowserCheck.isMobile;

        },
        /**
        * Initializes URLs of the images.
        * Following image URLS are initialized ,
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderbase64URL:property"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballBase64URL:property"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballShadowBase64URL:property"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballTextureBase64URL:property"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_asyncImageLoader:method"}}{{/crossLink}}.
        *
        * @method _initializeURLS
        * @private
        **/
        _initializeURLS: function () {
            var base64 = this.getJson('baseURL');
            this.stickySliderbase64URL = base64.stickySliderbase64URL;
            this.ballBase64URL = base64.ballBase64URL;
            this.ballShadowBase64URL = base64.ballShadowBase64URL;
            this.ballTextureBase64URL = base64.ballTextureBase64URL;
            this.ballTexureSmall = base64.ballTexureSmall;
        },

        /**
        * Initializes images from the URLs loaded by {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_initializeURLS:method"}}{{/crossLink}}.
        * This method is called only after {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_initializeURLS:method"}}{{/crossLink}} is called.
        * Following image rasters are initialized ,
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballShadowRaster:property"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballTextureRaster:property"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_asyncImageLoader:method"}}{{/crossLink}}.
        *
        * @method _asyncImageLoader
        * @private
        **/
        _asyncImageLoader: function () {
            var self = this,
                imagesLoaded = 0,
                imageCount = 4,
                paperScope = this.paperScope;
            this.stickySliderRaster = new paperScope.Raster({
                source: this.stickySliderbase64URL
            });
            this.ballInnerRaster = new paperScope.Raster({
                source: this.ballBase64URL
            });
            this.ballShadowRaster = new paperScope.Raster({
                source: this.ballShadowBase64URL
            });
            this.ballTextureRaster = new paperScope.Raster({
                // source: this.ballTextureBase64URL
                source: this.ballTexureSmall
            });


            this.stickySliderRaster.onLoad = function (event) {
                imagesLoaded++;
                self._triggerRender(imagesLoaded, imageCount);
            }
            this.ballInnerRaster.onLoad = function (event) {
                imagesLoaded++;
                self._triggerRender(imagesLoaded, imageCount);
            }
            this.ballShadowRaster.onLoad = function (event) {
                imagesLoaded++;
                this.size = [28, 28];// this patch was added to fix small texture raster
                self._triggerRender(imagesLoaded, imageCount);
            }
            this.ballTextureRaster.onLoad = function (event) {
                imagesLoaded++;
                self._triggerRender(imagesLoaded, imageCount);
            }
        },

        /**
        * Only after all rasters are loaded by {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_asyncImageLoader:method"}}{{/crossLink}}, rest of the rendering should be performed.
        *
        * @method _triggerRender
        * @param {Number} imagesLoaded indicates how many rasters are loaded
        * @param {Number} imageCount indicates how many total rasters are to be loaded by {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_asyncImageLoader:method"}}{{/crossLink}}.
        * @private
        **/
        _triggerRender: function (imagesLoaded, imageCount) {
            if (imageCount === imagesLoaded) {
                this.render();
            }
        },

        /**
        * Reads the properties supplied at the time of initialization.
        * If the "ball" is passed as an argument , in that case call of
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_asyncImageLoader:method"}}{{/crossLink}} and
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_initializeURLS:method"}}{{/crossLink}} are skipped.
        * Instead {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_clone:method"}}{{/crossLink}} is called . This is to optimize of raster creation frequency.
        * Function is called from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/initialize:method"}}{{/crossLink}}.
        *
        * @method _readProperties
        * @private
        **/
        _readProperties: function () {
            var options = this.options || {};
            this.paperScope = options.paperScope;
            this.ballModel = options.ballModel;
            if (options.ball) {
                this._clone(options.ball);
            }
            else {
                this._initializeURLS();
                this._asyncImageLoader();
            }
        },

        /**
        * Attaches events to the {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ball:property"}}{{/crossLink}},{{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}} and current model.
        * Function is called from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/render:method"}}{{/crossLink}}.
        *
        * @method _attachEvents
        * @private
        **/
        _attachEvents: function () {
            var dummyPath = this.dummyPath,
                stickySliderRaster = this.stickySliderRaster;




            dummyPath.onMouseDown = $.proxy(this._ballSelected, this);
            dummyPath.onMouseDrag = $.proxy(this._ballDragged, this);
            dummyPath.onMouseUp = $.proxy(this._ballDragFinished, this);
            dummyPath.onMouseEnter = $.proxy(this._onBallEnter, this);
            dummyPath.onMouseLeave = $.proxy(this._onBallLeave, this);

            stickySliderRaster.onMouseDown = $.proxy(this._stickySliderSelected, this);
            stickySliderRaster.onMouseDrag = $.proxy(this._stickySliderDragged, this);
            stickySliderRaster.onMouseUp = $.proxy(this._stickySliderDragFinished, this);
            stickySliderRaster.on('mouseenter', $.proxy(this._onSliderEnter, this));
            stickySliderRaster.on('mouseleave', $.proxy(this._onSliderLeave, this));

            this.listenTo(this.ballModel, 'change:isSnapped', $.proxy(this.ballSnapped, this));
        },

        /**
        * Clones the rasters if the "ball" option is supplied at the time of initialization.
        * Function is called from {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_readProperties:method"}}{{/crossLink}}.
        *
        * @method _clone
        * @param {Object} reference ball view.
        * @private
        **/
        _clone: function (ball) {
            var ballArg = ball;
            this.paperScope = ballArg.paperScope;
            this.ball = ballArg.ball.clone();
            this.stickySliderRaster = ballArg.stickySliderRaster.clone();
            this.ballShadowRaster = ballArg.ballShadowRaster.clone();
            this.ballInnerRaster = ballArg.ballInnerRaster.clone();
            this.ballTextureRaster = ballArg.ballTextureRaster.clone();
            this.render();
            this.hideGhostBall(true);
        },

        /**
        * Renders the view of ball.
        *
        * @method render
        * @public
        **/
        render: function render() {
            var ballGroup = null,
                stickySliderRaster = null;
            this._createStickySliderFocusRect();

            this.ball = this._clipBallBackground();

            stickySliderRaster = this.stickySliderRaster;


            this.ballGroup = ballGroup = new this.paperScope.Group(stickySliderRaster, this.ball);
            ballGroup.name = miniGolfModel.DRAGGABLE;

            stickySliderRaster.position = new this.paperScope.Point(-200, -200);
            ballGroup.position = new this.paperScope.Point(-100, -100);

            this.rectangleCover = new this.paperScope.Path.Rectangle({
                point: [0, 0],
                size: [this.ghostBall.bounds.width * 2, this.ghostBall.bounds.width],
                strokeColor: 'black',
                opacity: 0.4
            });
            this._attachEvents();
            this.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.RASTERS_LOADED);
            this.hideGhostBall(true);
            this.hideStickySlider(true);
            this.hideBallShadow(true);
            this._assignIds();
            this.setDisable(false);
        },
        _createStickySliderFocusRect: function () {

            var accConstants = miniGolfModel.ACC_DATA,
                stickySliderData = accConstants.STICKY_SLIDER_ACC_DATA;

            this.stickySliderFocusRect = new this.paperScope.Path.Rectangle({
                height: stickySliderData.HEIGHT,
                width: stickySliderData.WIDTH,
                strokeWidth: accConstants.STROKE_WIDTH,
                strokeColor: accConstants.STROKE_COLOR,
                dashArray: accConstants.DASH_ARRAY,
                visible: false

            })
            this.setStickySliderFocusRectPosition();



        },
        _assignIds: function () {
            var ballNames = MathInteractives.Interactivities.MiniGolf.Views.Ball.NAMES;
            this.ball.name = ballNames.BALL;
            this.stickySliderRaster.name = ballNames.STICKY_SLIDER;
            this.ball.cid = this.cid;
            this.stickySliderRaster.cid = this.cid;
        },

        /**
        * Renders the perpendicular line using {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/snapPoint:attribute"}}{{/crossLink}} and  {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/snapPoint:attribute"}}{{/crossLink}} when {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}} is set to true.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/setBallSnapPoint:method"}}{{/crossLink}},{{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballSnapped:method"}}{{/crossLink}}.
        *
        * @method _renderMirrorLine
        * @private
        **/
        _renderMirrorLine: function () {
            var ballModel = this.ballModel,
                paperScope = this.paperScope,
                mirrorLine = this.mirrorLine,
                ballViewClass = MathInteractives.Interactivities.MiniGolf.Views.Ball,
                isSnapped = ballModel.get('isSnapped');
            if (mirrorLine) {
                mirrorLine.remove();
            }
            if (isSnapped) {
                if (this._isNullOrUndefined(mirrorLine)) {
                    mirrorLine = new this.paperScope.Path();
                    mirrorLine.add(0, 0);
                    mirrorLine.add(0, 0);
                }
                var mirrorLineSegs = mirrorLine.segments;
                mirrorLineSegs[0].point = ballModel.get('snapPoint');
                mirrorLineSegs[1].point = ballModel.get('mirrorPoint');
                mirrorLine.strokeColor = ballViewClass.CONSTANTS.LINE_COLOR;
                mirrorLine.strokeWidth = ballViewClass.CONSTANTS.LINE_SHADOW;
                mirrorLine.dashArray = ballViewClass.CONSTANTS.DASH_ARRAY;
                this.mirrorLine = mirrorLine;
                this.setStickySliderPositionOnSnap();
                this.ballGroup.addChild(this.mirrorLine);
            }
            this.hideStickySlider(!isSnapped);
            if (this.ball) {
                this.ball.bringToFront();
            }
        },

        /**
        * Renders the round shaped ball by clipping the {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballTextureRaster:property"}}{{/crossLink}}.
        * Ball shadow is also positioned in this function using offset defined in the CONSTANTS.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/render:method"}}{{/crossLink}}.
        *
        * @method _clipBallBackground
        * @private
        **/
        _clipBallBackground: function () {
            var paperScope = this.paperScope,
                ballClass = MathInteractives.Interactivities.MiniGolf.Views.Ball,
                bounds = this.ballInnerRaster.bounds,
                innerRasterPosition = this.ballTextureRaster.position,
                accConstants = miniGolfModel.ACC_DATA,
                ballConstants = accConstants.BALL_ACC_DATA,
                pseudoCircle = new paperScope.Path.Circle({
                    center: innerRasterPosition,
                    radius: bounds.width / 2,
                    fillColor: 'white',
                    strokeColor: 'white'
                }),
                whiteCirle = pseudoCircle.clone(),
                clippedGroup = new paperScope.Group(pseudoCircle, this.ballTextureRaster);
            clippedGroup.clipped = true;
            this.ballShadowRaster.position = this._addPoints(whiteCirle.position, ballClass.CONSTANTS.SHADOW_OFFSET);
            this.ghostBall = new paperScope.Path.Circle({
                center: innerRasterPosition,
                radius: bounds.width / 2,
                strokeColor: ballClass.CONSTANTS.GHOST_BALL_COLOR,
                fillColor: ballClass.CONSTANTS.GHOST_BALL_COLOR
            });
            this.purpleBorder = new paperScope.Path.Circle({
                center: innerRasterPosition,
                radius: bounds.width / 2,
                strokeColor: ballClass.CONSTANTS.COLOR,
                strokeWidth: ballClass.CONSTANTS.PURPLE_BORDER_THICKNESS
            });
            this.dummyPath = new paperScope.Path.Circle({
                center: innerRasterPosition,
                radius: bounds.width / 2,
                fillColor: 'white',
                opacity: 0.01
            });

            this.ballFocusRect = new paperScope.Path.Rectangle({

                position: this.ballShadowRaster.position,
                height: ballConstants.HEIGHT,
                width: ballConstants.WIDTH,
                visible: false,
                dashArray: accConstants.DASH_ARRAY,
                strokeColor: accConstants.STROKE_COLOR,
                strokeWidth: accConstants.STROKE_WIDTH

            })
            return new paperScope.Group(this.ballShadowRaster, whiteCirle, clippedGroup, this.ballInnerRaster, this.purpleBorder, this.dummyPath, this.ballFocusRect);
        },

        /**
        * This function is called on change event of the model attribute {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/position:attribute"}}{{/crossLink}}.
        * Internally calls {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderMirrorLine:method"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_attachEvents:method"}}{{/crossLink}}.
        *
        * @method ballSnapped
        * @public
        **/
        ballSnapped: function () {
            var ballModel = this.ballModel,
                paperScope = this.paperScope,
                mirrorLine = this.mirrorLine,
                ballViewClass = MathInteractives.Interactivities.MiniGolf.Views.Ball,
                isSnapped = ballModel.get('isSnapped');
            if (mirrorLine) {
                this.ballGroup.removeChildren([this.mirrorLine]);
                mirrorLine.remove();

            }
            this.hideBall(isSnapped);
            this.hideBallShadow(isSnapped);
            this.hideGhostBall(!isSnapped)
            this._renderMirrorLine();

        },

        /**
        * Sets the position of {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballInnerRaster:property"}}{{/crossLink}} and translates the {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballGroup:property"}}{{/crossLink}}.
        * Sets the position in current model's {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/position:attribute"}}{{/crossLink}}.
        *
        * @method setBallPosition
        * @param {Object} newPosition new position of the {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballInnerRaster:property"}}{{/crossLink}} .
        * @public
        **/
        setBallPosition: function (newPosition) {
            newPosition = new this.paperScope.Point(newPosition);
            var origPosition = this.ball.position.clone(),
                translationVector = this._subtractPoints(newPosition, origPosition);
            this.ballGroup.translate(translationVector);
            this.ballInnerRaster.position = newPosition.clone();
            this.ghostBall.position = newPosition.clone();
            this.rectangleCover.position = newPosition.clone();
            this.ballModel.set('position', { x: newPosition.x, y: newPosition.y });
        },

        /**
        * Sets the position of {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}} and translates the {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/ballGroup:property"}}{{/crossLink}}.
        * Sets the position of ball in current model's {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/position:attribute"}}{{/crossLink}}.
        *
        * @method setStickySliderPosition
        * @param {Object} newPosition new position of the {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}}.
        * @public
        **/
        setStickySliderPosition: function (newPosition) {
            return;
            var origPosition = this.getBallPosition().clone(),
                translationVector = this._subtractPoints(newPosition, origPosition);

            this.stickySliderRaster.translate(translationVector);
            if (!this._isNullOrUndefined(this.ball)) {
                this.ball.translate(translationVector);
            }
            this.rectangleCover.translate(translationVector);
            this.ghostBall.translate(translationVector);
            this.mirrorLine.translate(translationVector);
            //this.ballGroup.translate(translationVector); // this lags performance while dragging , instead individual dragging is not causing performance issues.
            this.ballModel.set('position', newPosition);
        },

        /**
        * Snaps the ball to the boundry.
        * Called by {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderMirrorLine:method"}}{{/crossLink}}.
        *
        * @method setStickySliderPositionOnSnap
        * @public
        **/
        setStickySliderPositionOnSnap: function () {
            var ballModel = this.ballModel,
                height = MathInteractives.Interactivities.MiniGolf.Views.Ball.CONSTANTS.SLIDER_HEIGHT,
                distance = this.ballInnerRaster.bounds.width / 2 + height / 2,
                snapPoint = ballModel.get('snapPoint'),
                mirrorPoint = ballModel.get('mirrorPoint'),
                lineUtility = MathInteractives.Interactivities.MiniGolf.Views.LineUtility,
                stickySliderPosition = lineUtility.GetvarOnLineUsingDistance(this.ball.position, mirrorPoint, -distance, 0, true),
                angle = lineUtility.getAngleWithXAxis(mirrorPoint, snapPoint),
                currentSliderAngle = ballModel.get('stickySliderAngle');

            this.stickySliderRaster.position = new this.paperScope.Point(stickySliderPosition);
            if (currentSliderAngle === null || typeof currentSliderAngle === 'undefined') {
                this.stickySliderRaster.rotate(angle - 90);
                this.rectangleCover.rotate(angle - 90);
                ballModel.set('stickySliderAngle', angle);
                this.setStickySliderFocusRectPosition()
                return;
            }
            if (currentSliderAngle === angle) {
                return;
            }
            this.stickySliderRaster.rotate(angle - currentSliderAngle);
            this.rectangleCover.rotate(angle - currentSliderAngle);
            this.setStickySliderFocusRectPosition()
            ballModel.set('stickySliderAngle', angle);
        },

        /**
        * Sets the current model's
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/snapPoint:attribute"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/mirrorPoint:attribute"}}{{/crossLink}} and
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderMirrorLine:method"}}{{/crossLink}}.
        *
        * @method setBallSnap
        * @param {Boolean} snapped Boolean value of the ball .
        * @param {Object} snapPoint point on the surface.
        * @param {Object} mirrorPoint end point of the normal originated from snap point to the surface.
        * @public
        **/
        setBallSnap: function (snapped, snapPoint, mirrorPoint) {
            var ballModel = this.ballModel;
            ballModel.set('snapPoint', { x: snapPoint.x, y: snapPoint.y }); // in case one passed paper.js point object
            ballModel.set('mirrorPoint', { x: mirrorPoint.x, y: mirrorPoint.y }); // in case one passed paper.js point object
            ballModel.set('isSnapped', snapped);
            if (snapped) {
                this.ballTextureRaster.remove();
            }
        },

        /**
        * Returns the
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}} value.
        *
        * @method getBallSnap
        * @return {Boolean} whether the current ball is snapped or not.
        * @public
        **/
        getBallSnap: function () {
            return this.ballModel.get('isSnapped');
        },

        /**
        * Sets the current model's
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/snapPoint:attribute"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/mirrorPoint:attribute"}}{{/crossLink}} and
        * Internally calls {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_renderMirrorLine:method"}}{{/crossLink}}.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}}.
        *
        * @method setBallSnapPoint
        * @param {Object} snapPoint point on the surface.
        * @param {Object} mirrorPoint end point of the normal originated from snap point to the surface.
        * @public
        **/
        setBallSnapPoint: function (snapPoint, mirrorPoint) {
            var ballModel = this.ballModel;
            ballModel.set('snapPoint', { x: snapPoint.x, y: snapPoint.y }); // in case one passed paper.js point object
            ballModel.set('mirrorPoint', { x: mirrorPoint.x, y: mirrorPoint.y }); // in case one passed paper.js point object
            this._renderMirrorLine();
        },

        /**
        * Returns the model's
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/position:attribute"}}{{/crossLink}} value.
        *
        * @method getBallPosition
        * @return {Object} current ball's position.
        * @public
        **/
        getBallPosition: function () {
            return this.ballModel.get('position');
        },

        hideBall: function (hide) {
            var opacity = hide ? 0 : 1,
                ball = this.ball;
            if (opacity !== ball.opacity) {
                ball.opacity = opacity;
            }
        },

        hideBallShadow: function (hide) {
            var opacity = hide ? 0 : 1,
                ballShadowRaster = this.ballShadowRaster;
            if (opacity !== ballShadowRaster.opacity) {
                ballShadowRaster.opacity = opacity;
            }
        },

        hideStickySlider: function (hide) {
            !!hide// will give boolean value always
            var opacity = hide ? 0 : 1,
                stickySliderRaster = this.stickySliderRaster;
            if (this._isNullOrUndefined(stickySliderRaster)) {
                return;
            }
            stickySliderRaster.visible = !hide;// to set visibility of sticky slider to stop event prop on opacity 0
            if (opacity !== stickySliderRaster.opacity) {
                stickySliderRaster.opacity = opacity;
            }
        },

        hideGhostBall: function (hide) {
            var opacity = hide ? 0 : MathInteractives.Interactivities.MiniGolf.Views.Ball.CONSTANTS.GHOST_BALL_OPACITY,
                ghostball = this.ghostBall;
            if (!this._isNullOrUndefined(ghostball) && opacity !== ghostball.opacity) {
                ghostball.opacity = opacity;
            }
            this.rectangleCover.opacity = opacity;
        },

        hidePurpleBorder: function (hide) {
            var opacity = hide ? 0 : 1,
                purpleBorder = this.purpleBorder;
            if (!this._isNullOrUndefined(purpleBorder) && opacity !== purpleBorder.opacity) {
                purpleBorder.opacity = opacity;
            }
        },

        _islfLeftClick:function(paperEvent){
            var eventWhich=paperEvent.event.which;

            if(eventWhich===0||eventWhich===1){
                return true;
            }
            return false;

        },
        _ballSelected: function (event) {



            if (this._islfLeftClick(event)) {
                if (this.ball.opacity === 0) {
                    return;
                }
                this._closedHandCursor(event);
                var isSnapped = this.ballModel.get('isSnapped');
                if (!isSnapped && !this.isDisabled) {
                    this.stopReading();
                    this.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.BALL_SELECTED, event);
                }
                if (event.preventDefault) {

                    event.preventDefault();
                }
            }
        },

        /**
        * Triggers event on ball dragging only when {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}} is true.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_attachEvents:method"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/BALL_DRAGGED:event"}}{{/crossLink}}.
        *
        * @method _ballDragged
        * @private
        **/
        _ballDragged: function (event) {

            this.stopReading();
            if (this._islfLeftClick(event)) {
                var isSnapped = this.ballModel.get('isSnapped');
                if (!isSnapped && !this.isDisabled) {
                    this.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.BALL_DRAGGED, event);
                }
                this._closedHandCursor(event);
                event.preventDefault();
            }
        },

        /**
        * Triggers event on ball dragging finished only when {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}} is true.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_attachEvents:method"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/BALL_DRAGGING_FINISHED:event"}}{{/crossLink}}.
        *
        * @method _ballDragFinished
        * @private
        **/
        _ballDragFinished: function (event) {
            if (this._islfLeftClick(event)) {
                if (this.ball.opacity === 0) {
                    return;
                }
                this._openHandCursor(event);
                var isSnapped = this.ballModel.get('isSnapped'),
                    self = this;
                //self.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.BALL_DRAGGING_FINISHED, event);
                event.preventDefault();
            }
        },

        /**
        * Triggers event on ball when the mouse enters the ball
        * @method _onBallEnter
        * @private
        **/
        _onBallEnter: function _onBallEnter(event) {
            if (this.ball.opacity === 0) {
                return;
            }
            this._openHandCursor(event);
        },

        /**
        * Triggers event on ball when the mouse leaves the ball
        * @method _onBallEnter
        * @private
        **/
        _onBallLeave: function _onBallLeave(event) {
            this._defaultCursor();
        },

        /**
        * Triggers event on sticky slider when the mouse enters the slider
        * @method _onSliderEnter
        * @private
        **/
        _onSliderEnter: function _onSliderEnter(event) {
            this._openHandCursor(event);
        },

        /**
        * Triggers event on sticky slider when the mouse leaves the slider
        * @method _onSliderLeave
        * @private
        **/
        _onSliderLeave: function _onSliderLeave(event) {
            this._defaultCursor();
        },

        _stickySliderSelected: function (event) {
            if (this._islfLeftClick(event)) {
                this._closedHandCursor(event);
                this.rectangleCover.opacity = 0;
                if (!this.isDisabled) {
                    this.stopReading();
                    this.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.STICKYSLIDER_SELECTED, event);
                }
                this.setStickySliderFocusRectPosition();
                event.preventDefault();
            }
        },

        /**
        * Triggers event on {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}} dragging only when {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}} is false.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_attachEvents:method"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/STICKYSLIDER_DRAGGED:event"}}{{/crossLink}}.
        *
        * @method _stickySliderDragged
        * @private
        **/
        _stickySliderDragged: function (event) {
            if (this._islfLeftClick(event)) {
                if (!this.isDisabled) {
                    this.stopReading();
                    this.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.STICKYSLIDER_DRAGGED, event);
                }

                this._closedHandCursor(event);
                this.setStickySliderFocusRectPosition();
                event.preventDefault();
            }
        },
        setStickySliderFocusRectPosition: function setStickySliderFocusRectPosition() {
            var stickySliderFocusRect = this.stickySliderFocusRect;

            stickySliderFocusRect.position = this.stickySliderRaster.getPosition();
            stickySliderFocusRect.bringToFront();
        },
        /**
        * Triggers event on {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}} dragging finished only when {{#crossLink "MathInteractives.Interactivities.MiniGolf.Models.Ball/isSnapped:attribute"}}{{/crossLink}} is false.
        * See also {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_attachEvents:method"}}{{/crossLink}},
        * {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/STICKYSLIDER_DRAGGING_FINISHED:event"}}{{/crossLink}}.
        *
        * @method _stickySliderDragFinished
        * @private
        **/
        _stickySliderDragFinished: function (event) {
            if (this._islfLeftClick(event)) {
                //this.trigger(MathInteractives.Interactivities.MiniGolf.Views.Ball.EVENTS.STICKYSLIDER_DRAGGING_FINISHED, event);
                this._openHandCursor(event);
                this.setStickySliderFocusRectPosition();
            }
        },

        /**
        * Changes the cursor to the open hand cursor
        *
        * @method _openHandCursor
        * @private
        **/
        _openHandCursor: function _openHandCursor(event) {
            if (!this.isMobile && !event.isAccessibility) {
                $('#' + this.idPrefix + 'game-canvas-' + this.model.get('levelId')).css({ 'cursor': 'url("' + this.filePath.getImagePath('open-hand') + '"), move' });
            }
        },

        /**
        * Changes the cursor to the closed hand cursor
        *
        * @method _closedHandCursor
        * @private
        **/
        _closedHandCursor: function _closedHandCursor(event) {
            if (!this.isMobile && !event.isAccessibility) {
                $('#' + this.idPrefix + 'game-canvas-' + this.model.get('levelId')).css({ 'cursor': 'url("' + this.filePath.getImagePath('closed-hand') + '"), move' });
            }
        },

        /**
        * Changes the cursor to the default cursor
        *
        * @method _defaultCursor
        * @private
        **/
        _defaultCursor: function _defaultCursor() {
            if (!this.isMobile) {
                $('#' + this.idPrefix + 'game-canvas-' + this.model.get('levelId')).css({ 'cursor': 'default' });
            }
        },

        /**
        * Adds two points.
        *
        * @method _addPoints
        * @param {Object} point1 point
        * @param {Object} point2 point
        * @return {Object} Result of addition of point1 and point2
        * @private
        **/
        _addPoints: function (point1, point2) {
            return (point1 && point2) ? new this.paperScope.Point(point1.x + point2.x, point1.y + point2.y) : 'NaN';
        },

        /**
        * Subtracts two points.
        *
        * @method _subtractPoints
        * @param {Object} point1 point
        * @param {Object} point2 point
        * @return {Object} Result of subtraction of point1 and point2
        * @private
        **/
        _subtractPoints: function (point1, point2) {
            return (point1 && point2) ? new this.paperScope.Point(point1.x - point2.x, point1.y - point2.y) : 'NaN';
        },

        /**
        * Calculates mid point of two points.
        *
        * @method _getMidPoint
        * @param {Object} point1 point
        * @param {Object} point2 point
        * @return {Object} Mid point of point1 and point2
        * @private
        **/
        _getMidPoint: function (point1, point2) {
            return (point1 && point2) ? new this.paperScope.Point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2) : 'NaN';
        },

        /**
        * Compares whether x values for point1 and point2 are same or not.
        *
        * @method _equalX
        * @param {Object} pt1 point
        * @param {Object} pt2 point
        * @return {Boolean} whether both the x are same or not.
        * @private
        **/
        _equalX: function (pt1, pt2) {
            return Number(pt1.x.toFixed(4)) === Number(pt2.x.toFixed(4));
        },

        /**
        * Compares whether y values for point1 and point2 are same or not.
        *
        * @method _equalY
        * @param {Object} pt1 point
        * @param {Object} pt2 point
        * @return {Boolean} whether both the y are same or not.
        * @private
        **/
        _equalY: function (pt1, pt2) {
            return Number(pt1.y.toFixed(4)) === Number(pt2.y.toFixed(4));
        },

        _isNullOrUndefined: function (object) {
            return (object === null || typeof object === 'undefined');
        },

        remove: function () {
            var self = this,
                browserCheck = MathInteractives.Common.Utilities.Models.BrowserCheck,
                opacity = 1,
                step = 0.1;
            if (browserCheck.isIE || browserCheck.isFirefox || browserCheck.isNexus || browserCheck.isMobile) {
                step = 1;
            }

            if (true || browserCheck.isSafari || browserCheck.isNexus) {
                self._removePaperItems();
                return;
            }

            self.ballGroup.detach();
            self.stickySliderRaster.detach();
            self.ball.detach();
            self.ballGroup.onFrame = function (event) {

                if (opacity < 0) {
                    this.detach();
                    self._removePaperItems();
                }

                opacity -= step;
            }
        },

        setOpacity: function (opacity) {
            var self = this;
            if (!self._isNullOrUndefined(self.mirrorLine)) {
                self.mirrorLine.opacity = opacity;
            }
            self.ballTextureRaster.opacity = opacity;
            self.ballShadowRaster.opacity = opacity;
            if (!self._isNullOrUndefined(self.ballInnerRaster)) {
                self.ballInnerRaster.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.stickySliderRaster)) {
                self.stickySliderRaster.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.ballGroup)) {
                self.ballGroup.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.arcWithNextBall)) {
                self.arcWithNextBall.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.arcWithPrevBall)) {
                self.arcWithPrevBall.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.prevAngleText)) {
                self.prevAngleText.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.nextAngleText)) {
                self.nextAngleText.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.connectorLine)) {
                self.connectorLine.opacity = opacity;
            }
            if (!self._isNullOrUndefined(self.ghostBall)) {
                self.ghostBall.opacity = opacity * 0.4;
            }
            if (!self._isNullOrUndefined(self.rectangleCover)) {
                self.rectangleCover.opacity = opacity;
            }
        },

        _removePaperItems: function () {
            var self = this;
            self.ballTextureRaster.remove();
            self.ballShadowRaster.remove();
            self.ballInnerRaster.remove();
            self.deleteStickySlider();
            self.ballGroup.remove();
            self.deleteAngles();
            self.deleteConnectorLine();
            self.ghostBall.remove();
            self.deleteRectangleCover();
        },

        deleteRectangleCover: function () {
            var rectangleCover = this.rectangleCover;
            if (this._isNullOrUndefined(rectangleCover)) {
                return;
            }
            rectangleCover.detach();
            rectangleCover.remove();
            this.rectangleCover = null;
        },

        deleteBall: function () {
            var ball = this.ball;
            if (this._isNullOrUndefined(ball)) {
                return;
            }
            ball.detach();
            ball.remove();
            this.ball = null;
        },

        deleteStickySlider: function () {
            var stickySliderRaster = this.stickySliderRaster;
            if (this._isNullOrUndefined(stickySliderRaster)) {
                return;
            }
            stickySliderRaster.detach();
            stickySliderRaster.remove();
            this.stickySliderRaster = null;
        },

        deleteMirrorLine: function () {
            var mirrorLine = this.mirrorLine;
            if (this._isNullOrUndefined(mirrorLine)) {
                return;
            }
            mirrorLine.detach();
            mirrorLine.remove();
            this.mirrorLine = null;
        },

        deletePurpleBorder: function () {
            var purpleBorder = this.purpleBorder;
            if (this._isNullOrUndefined(purpleBorder)) {
                return;
            }
            purpleBorder.detach();
            purpleBorder.remove();
            this.purpleBorder = null;
        },

        deleteConnectorLine: function () {
            var connectorLine = this.connectorLine;
            if (this._isNullOrUndefined(connectorLine)) {
                return;
            }
            connectorLine.detach();
            connectorLine.remove();
            this.connectorLine = null;
        },

        getPaperItemsWhenSnapped: function (previous, next) {
            var self = this,
                array = [],
                ballModel = self.ballModel;
            if (ballModel.get('isSnapped')) {
                if (previous) {
                    if (!this._isNullOrUndefined(self.arcWithPrevBall)) {
                        array.push(self.arcWithPrevBall.id);
                    }

                    if (!this._isNullOrUndefined(self.prevAngleText)) {
                        array.push(self.prevAngleText.id);
                    }
                }
                if (next) {
                    if (!this._isNullOrUndefined(self.arcWithNextBall)) {
                        array.push(self.arcWithNextBall.id);
                    }
                    if (!this._isNullOrUndefined(self.nextAngleText)) {
                        array.push(self.nextAngleText.id);
                    }
                    if (!this._isNullOrUndefined(self.connectorLine)) {
                        array.push(self.connectorLine.id);
                    }
                }
                if (!this._isNullOrUndefined(self.mirrorLine)) {
                    array.push(self.mirrorLine.id);
                }
            }
            return array;
        },

        getActivePaperChildren: function () {
            return this.getPaperChildren();
        },

        getPaperChildren: function () {
            var array = [],
                self = this;
            if (!this._isNullOrUndefined(self.stickySliderRaster)) {
                array.push(self.stickySliderRaster.id);
            }
            if (!this._isNullOrUndefined(self.ghostBall)) {
                array.push(self.ghostBall.id);
            }
            if (!this._isNullOrUndefined(self.mirrorLine)) {
                array.push(self.mirrorLine.id);
            }
            if (!this._isNullOrUndefined(self.arcWithNextBall)) {
                array.push(self.arcWithNextBall.id);
            }
            if (!this._isNullOrUndefined(self.arcWithPrevBall)) {
                array.push(self.arcWithPrevBall.id);
            }
            if (!this._isNullOrUndefined(self.nextAngleText)) {
                array.push(self.nextAngleText.id);
            }
            if (!this._isNullOrUndefined(self.prevAngleText)) {
                array.push(self.prevAngleText.id);
            }
            if (!this._isNullOrUndefined(self.connectorLine)) {
                array.push(self.connectorLine.id);
            }
            if (!this._isNullOrUndefined(self.ball)) {
                array.push(self.ball.id);
            }
            return array;
        },

        deleteAngles: function () {
            if (!this._isNullOrUndefined(this.prevAngleText)) {
                this.prevAngleText.remove();
            }
            if (!this._isNullOrUndefined(this.arcWithPrevBall)) {
                this.arcWithPrevBall.remove();
            }
            if (!this._isNullOrUndefined(this.nextAngleText)) {
                this.nextAngleText.remove();
            }
            if (!this._isNullOrUndefined(this.arcWithNextBall)) {
                this.arcWithNextBall.remove();
            }
        },

        setDisable: function (disable) {
            this.isDisabled = disable;
        },
    },
                                                                                                            {
        EVENTS: {

            /**
        * Fired when all the rasters are loaded.
        *
        * Triggered in the function {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/render:method"}}{{/crossLink}}.
        * @event RASTERS_LOADED
        */
            RASTERS_LOADED: 'rastersloaded',

            /**
        * Fired when ball is dragged.
        *
        * Triggered in the function {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_ballDragged:method"}}{{/crossLink}}.
        * @event BALL_DRAGGED
        */
            BALL_DRAGGED: 'balldragged',

            /**
        * Fired when mouse up for the ball is encountered.
        *
        * Triggered in the function {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_ballDragFinished:method"}}{{/crossLink}}.
        * @event BALL_DRAGGING_FINISHED
        */
            BALL_DRAGGING_FINISHED: 'balldraggingFinished',

            /**
        * Fired when user drags {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}}.
        *
        * Triggered in the function {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_stickySliderDragged:method"}}{{/crossLink}}.
        * @event STICKYSLIDER_DRAGGED
        */
            STICKYSLIDER_DRAGGED: 'stickySliderdragged',

            /**
        * Fired when user finish dragging {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/stickySliderRaster:property"}}{{/crossLink}}.
        *
        * Triggered in the function {{#crossLink "MathInteractives.Interactivities.MiniGolf.Views.Ball/_stickySliderDragFinished:method"}}{{/crossLink}}.
        * @event STICKYSLIDER_DRAGGING_FINISHED
        */
            STICKYSLIDER_DRAGGING_FINISHED: 'stickySliderdraggingFinished',

            BALL_SELECTED: 'ballSelected',

            STICKYSLIDER_SELECTED: 'stickysliderSelected'
        },
        CONSTANTS: {
            SHADOW_OFFSET: { x: 0, y: 0 },
            LINE_COLOR: 'white',
            LINE_SHADOW: 2,
            DASH_ARRAY: [2, 1],
            PREV_ANGLE_SLICE: {
                RADIUS: 45,
                FILL_COLOR: '#FC00FF',
                FILL_ALPHA: 0.7,
                STROKE_COLOR: '#AC2AA9',
                STROKE_WIDTH: 2
            },
            NEXT_ANGLE_SLICE: {
                RADIUS: 60,
                FILL_COLOR: '#00CCFF',
                FILL_ALPHA: 0.7,
                STROKE_COLOR: '#0594AE',
                STROKE_WIDTH: 2
            },
            ANGLE_ARC_RADIUS: 40,
            ANGLE_TEXT_FONT_SIZE: 16,
            ANGLE_TEXT_FONT_FAMILY: 'montserrat',
            ANGLE_TEXT_STROKE_WIDTH: 0.1,
            INCIDENCE_ANGLE_LABEL_ARC_RAIDUS: 56, //48 + 16/2
            REFLECTION_ANGLE_LABEL_ARC_RAIDUS: 74, // 66 + 16/2
            ARC_COLOR: 'white',
            GHOST_BALL_COLOR: 'white',
            GHOST_BALL_OPACITY: 0.4,
            PURPLE_BORDER_THICKNESS: 3,
            COLOR: '#321066',
            SLIDER_HEIGHT: 33
        },
        NAMES: {
            BALL: 'ball',
            ROTATION_HANDLE: 'rotationHandle',
            STICKY_SLIDER: 'stickyslider',
            OBSTACLE: 'obstacle',
            OBSTACLE_ROTATION_HANDLE: 'obstacleRotationHandle'
        }
    });
})();
